/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#include <AzCore/Math/ToString.h>
#include <AzCore/Serialization/SerializeContext.h>
#include <AzFramework/Entity/EntityContext.h>
#include <AzFramework/Components/TransformComponent.h>
#include <AzTest/AzTest.h>
#include <AzToolsFramework/Application/ToolsApplication.h>
#include <AzToolsFramework/ToolsComponents/TransformComponent.h>
#include <AzToolsFramework/ToolsComponents/EditorLockComponent.h>
#include <AzToolsFramework/ToolsComponents/EditorVisibilityComponent.h>
#include <AzToolsFramework/Viewport/ActionBus.h>
#include <AzToolsFramework/ViewportSelection/EditorDefaultSelection.h>
#include <AzToolsFramework/ViewportSelection/EditorInteractionSystemViewportSelectionRequestBus.h>
#include <AzToolsFramework/ViewportSelection/EditorTransformComponentSelection.h>
#include <Tests/TestTypes.h>

#include <QtTest/QtTest>

using namespace AzToolsFramework;

// make gtest/gmock aware of these types so when a failure occurs we get more useful output
namespace AZ
{
    std::ostream& operator<<(std::ostream& os, const AZ::Vector3& vec) 
    {
        return os << AZ::ToString(vec).c_str();
    }

    std::ostream& operator<<(std::ostream& os, const AZ::Quaternion& quat) 
    {
        return os << AZ::ToString(quat).c_str();
    }
}

namespace UnitTest
{
    // Test widget to store QActions generated by EditorTransformComponentSelection
    class TestWidget
        : public QWidget
    {
    public:
        TestWidget()
            : QWidget()
        {
            // ensure TestWidget can intercept and filter any incoming events itself
            installEventFilter(this);
        }

        bool eventFilter(QObject* watched, QEvent* event) override
        {
            switch (event->type())
            {
            case QEvent::ShortcutOverride:
                {
                    const auto& cachedActions = actions();

                    // perform cast after type check (now safe to do so)
                    QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
                    // do our best to build a key sequence
                    // note: this will not handle more complex multi-key shortcuts at this time
                    const auto keySequence = QKeySequence(keyEvent->modifiers() + keyEvent->key());
                    // lookup the action that corresponds to this key event
                    const auto actionIt = AZStd::find_if(
                        cachedActions.begin(), cachedActions.end(), [keySequence](QAction* action)
                    {
                        return action->shortcut() == keySequence;
                    });

                    // if we get a match, generate the shortcut for this key combination
                    if (actionIt != cachedActions.end())
                    {
                        // trigger shortcut
                        QShortcutEvent shortcutEvent(keySequence, 0);
                        QApplication::sendEvent(*actionIt, &shortcutEvent);
                        keyEvent->accept();
                        return true;
                    }
                }
                // fallthrough
            default:
                return false;
            }
        }
    };

    // Fixture to support testing EditorTransformComponentSelection functionality on an Entity selection.
    class EditorTransformComponentSelectionTest
        : public AllocatorsTestFixture
        , private NewViewportInteractionModelEnabledRequestBus::Handler
        , private EditorActionRequestBus::Handler
    {
    public:
        void SetUp() override
        {
            NewViewportInteractionModelEnabledRequestBus::Handler::BusConnect();
            EditorActionRequestBus::Handler::BusConnect();

            m_app.Start(AzFramework::Application::Descriptor());

            m_testWidget.setFocus();

            EditorInteractionSystemViewportSelectionRequestBus::Event(
                GetEntityContextId(), &EditorInteractionSystemViewportSelection::SetDefaultHandler);

            m_entityIds.push_back(CreateEditorEntity("Entity"));

            ToolsApplicationRequestBus::Broadcast(
                &ToolsApplicationRequests::SetSelectedEntities, m_entityIds);
        }

        void TearDown() override
        {
            EditorActionRequestBus::Handler::BusDisconnect();
            NewViewportInteractionModelEnabledRequestBus::Handler::BusDisconnect();

            m_app.Stop();
        }

        AZ::EntityId CreateEditorEntity(const char* name)
        {
            AZ::Entity* entity = nullptr;
            AzFramework::EntityContextRequestBus::BroadcastResult(
                entity, &AzFramework::EntityContextRequests::CreateEntity, name);

            entity->Init();

            // add required components for the Editor entity
            entity->CreateComponent<Components::TransformComponent>();
            entity->CreateComponent<Components::EditorLockComponent>();
            entity->CreateComponent<Components::EditorVisibilityComponent>();

            entity->Activate();

            return entity->GetId();
        }

        void ArrangeIndividualRotatedEntitySelection(const AZ::Quaternion& orientation)
        {
            for (const auto entityId : m_entityIds)
            {
                AZ::TransformBus::Event(
                    entityId, &AZ::TransformBus::Events::SetLocalRotationQuaternion, orientation);
            }
        }

        AZStd::optional<AZ::Transform> GetManipulatorTransform() const
        {
            AZStd::optional<AZ::Transform> manipulatorTransform;
            EditorTransformComponentSelectionRequestBus::EventResult(
                manipulatorTransform, GetEntityContextId(),
                &EditorTransformComponentSelectionRequests::GetManipulatorTransform);
            return manipulatorTransform;
        }

        void RefreshManipulators(EditorTransformComponentSelectionRequests::RefreshType refreshType)
        {
            EditorTransformComponentSelectionRequestBus::Event(
                GetEntityContextId(), &EditorTransformComponentSelectionRequests::RefreshManipulators, refreshType);
        }

        void SetTransformMode(EditorTransformComponentSelectionRequests::Mode transformMode)
        {
            EditorTransformComponentSelectionRequestBus::Event(
                GetEntityContextId(), &EditorTransformComponentSelectionRequests::SetTransformMode, transformMode);
        }

        void OverrideManipulatorOrientation(const AZ::Quaternion& orientation)
        {
            EditorTransformComponentSelectionRequestBus::Event(
                GetEntityContextId(), &EditorTransformComponentSelectionRequests::OverrideManipulatorOrientation,
                orientation);
        }

        void OverrideManipulatorTranslation(const AZ::Vector3& translation)
        {
            EditorTransformComponentSelectionRequestBus::Event(
                GetEntityContextId(), &EditorTransformComponentSelectionRequests::OverrideManipulatorTranslation,
                translation);
        }

    private:
        // NewViewportInteractionModelEnabledRequestBus
        bool IsNewViewportInteractionModelEnabled() override;

        // EditorActionRequestBus
        void AddActionViaBus(int id, QAction* action) override;
        void RemoveActionViaBus(QAction* action) override;
        void EnableDefaultActions() override {}
        void DisableDefaultActions() override {}
        void AttachOverride(QWidget* object) override {}
        void DetachOverride() override {}

    public:
        ToolsApplication m_app;
        TestWidget m_testWidget;
        EntityIdList m_entityIds;
    };

    void EditorTransformComponentSelectionTest::AddActionViaBus(int id, QAction* action)
    {
        action->setData(id);
        action->setShortcutContext(Qt::ApplicationShortcut);
        m_testWidget.addAction(action);
    }

    void  EditorTransformComponentSelectionTest::RemoveActionViaBus(QAction* action)
    {
        m_testWidget.removeAction(action);
    }

    bool EditorTransformComponentSelectionTest::IsNewViewportInteractionModelEnabled()
    {
        return true;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // EditorTransformComponentSelection Tests

    // matcher to make tests easier to read and failures more useful (more information is included in the output)
    MATCHER_P(IsClose, v, "") { return arg.IsClose(v); }

    TEST_F(EditorTransformComponentSelectionTest, ManipulatorOrientationIsResetWhenEntityOrientationIsReset)
    {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Given
        ArrangeIndividualRotatedEntitySelection(AZ::Quaternion::CreateRotationX(AZ::DegToRad(90.0f)));
        RefreshManipulators(EditorTransformComponentSelectionRequests::RefreshType::All);
            
        SetTransformMode(EditorTransformComponentSelectionRequests::Mode::Rotation);

        const AZ::Transform manipulatorTransformBefore =
            GetManipulatorTransform().value_or(AZ::Transform::CreateIdentity());
        
        // check preconditions - manipulator transform matches entity transform
        EXPECT_THAT(manipulatorTransformBefore.GetBasisY(), IsClose(AZ::Vector3::CreateAxisZ()));
        EXPECT_THAT(manipulatorTransformBefore.GetBasisZ(), IsClose(-AZ::Vector3::CreateAxisY()));
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // When
        // R - reset entity and manipulator orientation when in Rotation Mode
        QTest::keyPress(&m_testWidget, Qt::Key_R);
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Then
        const AZ::Transform manipulatorTransformAfter =
            GetManipulatorTransform().value_or(AZ::Transform::CreateIdentity());

        // check postconditions - manipulator transform matches identity transform
        EXPECT_THAT(manipulatorTransformAfter.GetBasisY(), IsClose(AZ::Vector3::CreateAxisY()));
        EXPECT_THAT(manipulatorTransformAfter.GetBasisZ(), IsClose(AZ::Vector3::CreateAxisZ()));

        for (const auto entityId : m_entityIds)
        {
            AZ::Quaternion entityOrientation;
            AZ::TransformBus::EventResult(
                entityOrientation, entityId, &AZ::TransformBus::Events::GetLocalRotationQuaternion);

            // manipulator orientation matches entity orientation
            EXPECT_THAT(entityOrientation, IsClose(
                AZ::Quaternion::CreateRotationFromUnscaledTransform(manipulatorTransformAfter)));
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }

    TEST_F(EditorTransformComponentSelectionTest, EntityOrientationRemainsConstantWhenOnlyManipulatorOrientationIsReset)
    {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Given
        const AZ::Quaternion initialEntityOrientation = AZ::Quaternion::CreateRotationX(AZ::DegToRad(90.0f));
        ArrangeIndividualRotatedEntitySelection(initialEntityOrientation);

        // assign new orientation to manipulator which does not match entity orientation
        OverrideManipulatorOrientation(AZ::Quaternion::CreateRotationZ(AZ::DegToRad(90.0f)));
            
        SetTransformMode(EditorTransformComponentSelectionRequests::Mode::Rotation);

        const AZ::Transform manipulatorTransformBefore =
            GetManipulatorTransform().value_or(AZ::Transform::CreateIdentity());

        // check preconditions - manipulator transform matches manipulator orientation override (not entity transform)
        EXPECT_THAT(manipulatorTransformBefore.GetBasisX(), IsClose(AZ::Vector3::CreateAxisY()));
        EXPECT_THAT(manipulatorTransformBefore.GetBasisY(), IsClose(-AZ::Vector3::CreateAxisX()));
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // When
        // Ctrl+R - reset only manipulator orientation when in Rotation Mode
        QTest::keyPress(&m_testWidget, Qt::Key_R, Qt::ControlModifier);
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Then
        const AZ::Transform manipulatorTransformAfter =
            GetManipulatorTransform().value_or(AZ::Transform::CreateIdentity());

        // check postconditions - manipulator transform matches entity transform (manipulator override was cleared)
        EXPECT_THAT(manipulatorTransformAfter.GetBasisY(), IsClose(AZ::Vector3::CreateAxisZ()));
        EXPECT_THAT(manipulatorTransformAfter.GetBasisZ(), IsClose(-AZ::Vector3::CreateAxisY()));

        for (const auto entityId : m_entityIds)
        {
            AZ::Quaternion entityOrientation;
            AZ::TransformBus::EventResult(
                entityOrientation, entityId, &AZ::TransformBus::Events::GetLocalRotationQuaternion);

            // entity transform matches initial (entity transform was not reset, only manipulator was)
            EXPECT_THAT(entityOrientation, IsClose(initialEntityOrientation));
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }
} // namespace UnitTest